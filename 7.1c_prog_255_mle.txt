#!/usr/bin/env python3
"""
COMPLETE QUANTUM STATE TOMOGRAPHY WITH PROPER RECONSTRUCTION
============================================================
Full 255-basis tomography with Maximum Likelihood Estimation
for accurate density matrix reconstruction including coherences.

Key improvements over diagonal-only reconstruction:
1. Proper Pauli operator construction for each measurement basis
2. Maximum likelihood estimation with physical constraints
3. Off-diagonal coherence extraction
4. Validation against analytical Bell state predictions
"""

import numpy as np
from qbraid.runtime import QbraidProvider
from qiskit import QuantumCircuit
import time
from datetime import datetime
import pandas as pd
from itertools import product
import os
from scipy.optimize import minimize
from scipy.linalg import sqrtm

# ============================================================================
# SET API KEY
# ============================================================================
os.environ['QBRAID_API_KEY'] = 'xxx'

# ============================================================================
# CONFIGURATION
# ============================================================================
MAX_JOBS_PER_BATCH = 55  # Conservative limit for IonQ
BATCH_DELAY = 1  # Seconds between batches
N_QUBITS = 4
SHOTS = 500
ANGLES = [45]  # Test angle - can expand to [0, 15, 30, 45, 60, 75, 90]

print("=" * 80)
print("PROPER QUANTUM STATE TOMOGRAPHY - 255 BASES × 500 SHOTS")
print("With Maximum Likelihood Estimation for Full Density Matrix")
print("=" * 80)

# ============================================================================
# PAULI MATRIX LIBRARY
# ============================================================================
def get_pauli_matrix(pauli_char):
    """Return 2x2 Pauli matrix"""
    if pauli_char == 'I':
        return np.array([[1, 0], [0, 1]], dtype=complex)
    elif pauli_char == 'X':
        return np.array([[0, 1], [1, 0]], dtype=complex)
    elif pauli_char == 'Y':
        return np.array([[0, -1j], [1j, 0]], dtype=complex)
    elif pauli_char == 'Z':
        return np.array([[1, 0], [0, -1]], dtype=complex)
    else:
        raise ValueError(f"Unknown Pauli: {pauli_char}")

def construct_pauli_operator(pauli_string):
    """Construct n-qubit Pauli operator from string like 'XYZI'"""
    operator = get_pauli_matrix(pauli_string[0])
    for pauli_char in pauli_string[1:]:
        operator = np.kron(operator, get_pauli_matrix(pauli_char))
    return operator

def construct_measurement_projector(basis_string, outcome_bitstring):
    """
    Construct projector for specific measurement outcome.
    
    basis_string: e.g., 'XYZI' - measurement basis for each qubit
    outcome_bitstring: e.g., '0101' - measurement outcome
    
    Returns: Projector operator corresponding to this outcome in this basis
    """
    projector = np.eye(1, dtype=complex)
    
    for pauli_char, outcome_bit in zip(basis_string, outcome_bitstring):
        pauli = get_pauli_matrix(pauli_char)
        
        # Eigenvector for outcome (0 -> +1 eigenvalue, 1 -> -1 eigenvalue)
        if outcome_bit == '0':
            eigenvalue = 1
        else:
            eigenvalue = -1
        
        # Construct projector: P = (I + eigenvalue * Pauli) / 2
        local_projector = (np.eye(2) + eigenvalue * pauli) / 2
        
        projector = np.kron(projector, local_projector)
    
    # Remove initial dummy dimension
    if projector.shape[0] == 1:
        projector = projector[0, 0] * np.eye(2**len(basis_string))
    
    return projector

# ============================================================================
# DENSITY MATRIX PARAMETERIZATION (CHOLESKY)
# ============================================================================
def params_to_density_matrix(params, dim):
    """
    Convert real parameters to valid density matrix using Cholesky decomposition.
    This ensures the result is positive semi-definite and Hermitian.
    
    For dim×dim matrix, we need dim² real parameters.
    """
    # Reconstruct complex lower triangular matrix
    T = np.zeros((dim, dim), dtype=complex)
    idx = 0
    
    for i in range(dim):
        for j in range(i + 1):
            if i == j:
                # Diagonal: positive real
                T[i, i] = params[idx]
                idx += 1
            else:
                # Off-diagonal: complex
                T[i, j] = params[idx] + 1j * params[idx + 1]
                idx += 2
    
    # rho = T @ T†
    rho = T @ T.conj().T
    
    # Normalize
    trace = np.trace(rho)
    if trace > 1e-10:
        rho = rho / trace
    
    return rho

def density_matrix_to_params(rho):
    """Convert density matrix to Cholesky parameters"""
    dim = rho.shape[0]
    
    # Cholesky decomposition: rho = T @ T†
    T = np.linalg.cholesky(rho + 1e-10 * np.eye(dim))  # Add small regularization
    
    params = []
    for i in range(dim):
        for j in range(i + 1):
            if i == j:
                params.append(np.real(T[i, i]))
            else:
                params.append(np.real(T[i, j]))
                params.append(np.imag(T[i, j]))
    
    return np.array(params)

# ============================================================================
# MAXIMUM LIKELIHOOD ESTIMATION
# ============================================================================
def maximum_likelihood_tomography(measurement_data, dim, max_iterations=1000):
    """
    Reconstruct density matrix using Maximum Likelihood Estimation.
    
    measurement_data: List of (projector, observed_probability) tuples
    dim: Hilbert space dimension (2^n_qubits)
    
    Returns: Reconstructed density matrix
    """
    print(f"\n    Running MLE with {len(measurement_data)} constraints...", end='', flush=True)
    
    # Initial guess: maximally mixed state
    rho_initial = np.eye(dim) / dim
    params_initial = density_matrix_to_params(rho_initial)
    
    # Likelihood function (negative for minimization)
    def negative_log_likelihood(params):
        rho = params_to_density_matrix(params, dim)
        
        log_likelihood = 0
        for projector, observed_prob in measurement_data:
            # Expected probability: Tr(Π_i ρ)
            expected_prob = np.real(np.trace(projector @ rho))
            
            # Avoid log(0)
            expected_prob = np.clip(expected_prob, 1e-10, 1 - 1e-10)
            observed_prob = np.clip(observed_prob, 1e-10, 1 - 1e-10)
            
            # Log likelihood contribution
            log_likelihood += observed_prob * np.log(expected_prob)
        
        return -log_likelihood
    
    # Optimize
    result = minimize(
        negative_log_likelihood,
        params_initial,
        method='BFGS',
        options={'maxiter': max_iterations, 'disp': False}
    )
    
    rho_reconstructed = params_to_density_matrix(result.x, dim)
    
    print(" ✓")
    print(f"    MLE converged: {result.success}, Iterations: {result.nit}")
    
    return rho_reconstructed

# ============================================================================
# PROPER DENSITY MATRIX RECONSTRUCTION
# ============================================================================
def reconstruct_density_matrix_proper(measurement_results, bases_used, n_qubits):
    """
    Properly reconstruct density matrix from tomography data using MLE.
    This extracts BOTH diagonal populations AND off-diagonal coherences.
    """
    dim = 2**n_qubits
    measurement_data = []
    
    print(f"\n    Building measurement constraints from {len(bases_used)} bases...")
    
    # For each measurement basis
    for basis, result in zip(bases_used, measurement_results):
        counts = result.data.get_counts()
        total_shots = sum(counts.values())
        
        # For each possible measurement outcome
        for outcome_bitstring in [format(i, f'0{n_qubits}b') for i in range(dim)]:
            # Construct projector for this outcome in this basis
            projector = construct_measurement_projector(basis, outcome_bitstring)
            
            # Observed probability
            observed_prob = counts.get(outcome_bitstring, 0) / total_shots
            
            measurement_data.append((projector, observed_prob))
    
    print(f"    Total measurement constraints: {len(measurement_data)}")
    
    # Maximum likelihood reconstruction
    rho = maximum_likelihood_tomography(measurement_data, dim)
    
    # Enforce exact Hermiticity and normalization
    rho = (rho + rho.conj().T) / 2
    rho = rho / np.trace(rho)
    
    return rho

# ============================================================================
# ANALYTICAL BELL STATE (FOR VALIDATION)
# ============================================================================
def analytical_bell_state(theta_deg, n_qubits=4):
    """
    Construct analytical Bell state density matrix.
    
    |ψ⟩ = (|00⟩ + e^{iθ}|11⟩)/√2 on qubits 0,1
    |ψ⟩ ⊗ |00⟩ on qubits 2,3
    """
    theta_rad = np.radians(theta_deg)
    
    # 2-qubit Bell state
    bell_vec = np.zeros(4, dtype=complex)
    bell_vec[0] = 1/np.sqrt(2)  # |00⟩
    bell_vec[3] = np.exp(1j * theta_rad) / np.sqrt(2)  # |11⟩
    
    # Tensor with |00⟩ for remaining qubits
    full_vec = bell_vec
    for _ in range(n_qubits - 2):
        zero_vec = np.array([1, 0], dtype=complex)
        full_vec = np.kron(full_vec, zero_vec)
    
    # Density matrix
    rho_analytical = np.outer(full_vec, full_vec.conj())
    
    return rho_analytical

# ============================================================================
# QUANTUM INFORMATION MEASURES
# ============================================================================
def von_neumann_entropy(rho):
    """Calculate von Neumann entropy: S = -Tr(ρ log₂ ρ)"""
    eigenvalues = np.linalg.eigvalsh(rho)
    eigenvalues = eigenvalues[eigenvalues > 1e-10]
    return -np.sum(eigenvalues * np.log2(eigenvalues + 1e-10))

def partial_trace(rho_AB, subsystem_to_trace, dims):
    """
    Partial trace over specified subsystem.
    
    dims: tuple (dim_A, dim_B) for bipartite system
    subsystem_to_trace: 0 (trace over A) or 1 (trace over B)
    """
    dim_A, dim_B = dims
    
    if subsystem_to_trace == 0:  # Trace over A, return rho_B
        rho_reduced = np.zeros((dim_B, dim_B), dtype=complex)
        for i in range(dim_B):
            for j in range(dim_B):
                rho_reduced[i, j] = sum(rho_AB[k*dim_B + i, k*dim_B + j] for k in range(dim_A))
    else:  # Trace over B, return rho_A
        rho_reduced = np.zeros((dim_A, dim_A), dtype=complex)
        for i in range(dim_A):
            for j in range(dim_A):
                rho_reduced[i, j] = sum(rho_AB[i*dim_B + k, j*dim_B + k] for k in range(dim_B))
    
    return rho_reduced

def quantum_discord_proper(rho_AB, dims=(4, 4)):
    """
    Calculate quantum discord properly using full density matrix.
    
    Discord = I(A:B) - max_Π J(A:B|Π)
    
    For simplicity, we approximate max over measurements by Z-basis measurement.
    """
    dim_A, dim_B = dims
    
    # Full system entropy
    S_AB = von_neumann_entropy(rho_AB)
    
    # Subsystem entropies
    rho_A = partial_trace(rho_AB, subsystem_to_trace=1, dims=dims)
    rho_B = partial_trace(rho_AB, subsystem_to_trace=0, dims=dims)
    
    S_A = von_neumann_entropy(rho_A)
    S_B = von_neumann_entropy(rho_B)
    
    # Quantum mutual information
    I_quantum = S_A + S_B - S_AB
    
    # Classical correlation (Z-basis measurement on B)
    # This is a simplified approximation
    I_classical = I_quantum  # Upper bound
    
    # Discord (simplified as quantum mutual information)
    discord = max(0, I_quantum)
    
    return discord, S_A, S_B, S_AB, I_classical

def fidelity(rho1, rho2):
    """Calculate fidelity F(ρ₁,ρ₂) = Tr(√(√ρ₁ ρ₂ √ρ₁))²"""
    sqrt_rho1 = sqrtm(rho1)
    product = sqrtm(sqrt_rho1 @ rho2 @ sqrt_rho1)
    return np.real(np.trace(product))**2

# ============================================================================
# CIRCUIT CREATION
# ============================================================================
def create_bell_circuit(theta_deg, basis_string, n_qubits=4):
    """Create Bell state with tomography measurement basis"""
    qc = QuantumCircuit(n_qubits)
    
    # Bell pair on qubits 0,1
    qc.h(0)
    qc.cx(0, 1)
    
    # Rotation on qubit 0
    theta_rad = np.radians(theta_deg)
    qc.rz(theta_rad, 0)
    
    # Apply measurement basis transformations
    for i, pauli in enumerate(basis_string):
        if pauli == 'X':
            qc.h(i)
        elif pauli == 'Y':
            qc.sdg(i)
            qc.h(i)
        # 'Z' and 'I' require no transformation
    
    return qc

# ============================================================================
# GENERATE MEASUREMENT BASES
# ============================================================================
def generate_all_tomography_bases(n_qubits):
    """Generate ALL 255 Pauli measurement bases (excluding all-identity)"""
    paulis = ['I', 'X', 'Y', 'Z']
    bases = []
    
    for pauli_string in product(paulis, repeat=n_qubits):
        bases.append(''.join(pauli_string))
    
    # Remove all-identity
    bases = [b for b in bases if b != 'I' * n_qubits]
    
    return bases

# ============================================================================
# BATCH SUBMISSION
# ============================================================================
def submit_batch(circuits, batch_name, bases):
    """Submit batch of circuits and retrieve results"""
    print(f"\n  Batch {batch_name}:")
    print(f"    Submitting {len(circuits)} jobs...", end='', flush=True)
    
    try:
        jobs = []
        for circuit in circuits:
            job = device.run(circuit, shots=SHOTS)
            jobs.append(job)
        
        print(f" ✓ ({len(jobs)} jobs submitted)")
        print(f"    Waiting for results...", end='', flush=True)
        
        results = []
        for job in jobs:
            result = job.result()
            results.append(result)
        
        print(" ✓")
        return results
        
    except Exception as e:
        print(f" ✗")
        print(f"    Error: {e}")
        return []

# ============================================================================
# CONNECT TO QBRAID + IONQ
# ============================================================================
try:
    provider = QbraidProvider()
    device = provider.get_device('ionq_simulator')
    
    print(f"\n✓ Connected to: {device.id}")
    print(f"✓ Status: {device.status()}")
except Exception as e:
    print(f"\n✗ Connection error: {e}")
    raise

# ============================================================================
# GENERATE BASES
# ============================================================================
bases = generate_all_tomography_bases(N_QUBITS)
print(f"\n✓ Generated {len(bases)} measurement bases")
print(f"  Examples: {bases[0]}, {bases[1]}, ..., {bases[-1]}")

# ============================================================================
# MAIN TOMOGRAPHY EXECUTION
# ============================================================================
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
summary_file = f"tomography_proper_mle_{timestamp}.csv"

summary_data = []

for angle_idx, theta in enumerate(ANGLES):
    print("\n" + "=" * 80)
    print(f"PROPER TOMOGRAPHY: θ = {theta}° (255 bases with MLE reconstruction)")
    print("=" * 80)
    
    # Split into batches
    n_batches = (len(bases) + MAX_JOBS_PER_BATCH - 1) // MAX_JOBS_PER_BATCH
    print(f"\nTotal measurements: {len(bases)}")
    print(f"Batches: {n_batches} × ~{MAX_JOBS_PER_BATCH} jobs")
    
    angle_results = []
    angle_bases = []
    
    start_time = time.time()
    
    # Execute batches
    for batch_idx in range(n_batches):
        start_idx = batch_idx * MAX_JOBS_PER_BATCH
        end_idx = min(start_idx + MAX_JOBS_PER_BATCH, len(bases))
        batch_bases = bases[start_idx:end_idx]
        
        circuits = [create_bell_circuit(theta, basis) for basis in batch_bases]
        
        batch_name = f"{angle_idx+1}.{batch_idx+1}/{n_batches}"
        results = submit_batch(circuits, batch_name, batch_bases)
        
        angle_results.extend(results)
        angle_bases.extend(batch_bases)
        
        print(f"  Progress: {len(angle_results)}/{len(bases)} bases complete")
        
        if batch_idx < n_batches - 1:
            print(f"  Waiting {BATCH_DELAY}s before next batch...")
            time.sleep(BATCH_DELAY)
    
    elapsed = time.time() - start_time
    
    # ========================================================================
    # PROPER RECONSTRUCTION WITH MLE
    # ========================================================================
    print(f"\n  Reconstructing density matrix with MLE...")
    rho_measured = reconstruct_density_matrix_proper(angle_results, angle_bases, N_QUBITS)
    
    # Analytical comparison
    rho_analytical = analytical_bell_state(theta, N_QUBITS)
    
    # Calculate fidelity
    fid = fidelity(rho_measured, rho_analytical)
    
    # Calculate quantum information
    print(f"  Calculating quantum discord...", end='', flush=True)
    discord, S_A, S_B, S_AB, I_classical = quantum_discord_proper(rho_measured, dims=(4, 4))
    print(" ✓")
    
    # Analytical discord
    theta_rad = np.radians(theta)
    discord_analytical = abs(np.cos(theta_rad/2)**2 - 0.5)
    
    purity = np.real(np.trace(rho_measured @ rho_measured))
    
    # ========================================================================
    # COHERENCE ANALYSIS
    # ========================================================================
    print(f"\n  Analyzing coherence structure...")
    
    # Extract key coherence terms
    coherence_00_11 = rho_measured[0, 15]  # |0000⟩ ↔ |1111⟩ (should be zero)
    coherence_00_03 = rho_measured[0, 3]   # |0000⟩ ↔ |0011⟩ (Bell coherence)
    
    # Analytical expectation
    coherence_analytical = rho_analytical[0, 3]
    
    coherence_error = abs(coherence_00_03 - coherence_analytical)
    
    print(f"    Key coherence |0000⟩↔|0011⟩:")
    print(f"      Measured:    {coherence_00_03:.6f}")
    print(f"      Analytical:  {coherence_analytical:.6f}")
    print(f"      Error:       {coherence_error:.6f}")
    
    # ========================================================================
    # RESULTS SUMMARY
    # ========================================================================
    print("\n" + "─" * 80)
    print("PROPER TOMOGRAPHY RESULTS (WITH COHERENCES):")
    print("─" * 80)
    print(f"Quantum Discord:")
    print(f"  Measured:    {discord:.6f} bits")
    print(f"  Analytical:  {discord_analytical:.6f} bits")
    if discord_analytical > 0:
        error_pct = abs(discord - discord_analytical)/discord_analytical*100
        print(f"  Error:       {error_pct:.2f}%")
    
    print(f"\nEntropies:")
    print(f"  S(A)  = {S_A:.4f} bits")
    print(f"  S(B)  = {S_B:.4f} bits")
    print(f"  S(AB) = {S_AB:.4f} bits")
    print(f"  I_quantum = {I_classical:.4f} bits")
    
    print(f"\nState Quality:")
    print(f"  Purity:   {purity:.4f} (ideal = 1.0)")
    print(f"  Fidelity: {fid:.4f} (ideal = 1.0)")
    
    print(f"\nCoherence Quality:")
    print(f"  Coherence extraction successful: {'✓' if abs(coherence_00_03) > 0.01 else '✗'}")
    print(f"  Coherence accuracy: {(1 - coherence_error/abs(coherence_analytical))*100:.1f}%")
    
    print(f"\nPerformance:")
    print(f"  Time:        {elapsed/60:.1f} minutes ({elapsed:.1f}s)")
    print(f"  Total bases: {len(angle_results)}")
    print(f"  Total shots: {len(angle_results) * SHOTS:,}")
    print(f"  Throughput:  {len(angle_results) * SHOTS / elapsed:.1f} shots/sec")
    print("─" * 80)
    
    # Save summary
    summary_data.append({
        'theta': theta,
        'discord_measured': discord,
        'discord_analytical': discord_analytical,
        'discord_error_pct': abs(discord - discord_analytical)/discord_analytical*100 if discord_analytical > 0 else 0,
        'S_A': S_A,
        'S_B': S_B,
        'S_AB': S_AB,
        'I_quantum': I_classical,
        'purity': purity,
        'fidelity': fid,
        'coherence_measured': abs(coherence_00_03),
        'coherence_analytical': abs(coherence_analytical),
        'coherence_error': coherence_error,
        'elapsed_time': elapsed,
        'total_bases': len(angle_results),
        'shots_per_basis': SHOTS,
        'total_shots': len(angle_results) * SHOTS
    })

# Save summary
df_summary = pd.DataFrame(summary_data)
df_summary.to_csv(summary_file, index=False)
print(f"\n✓ Summary saved to: {summary_file}")

print("\n" + "=" * 80)
print("PROPER TOMOGRAPHY COMPLETE - WITH MAXIMUM LIKELIHOOD ESTIMATION")
print("=" * 80)
print(f"\nKey improvements:")
print(f"  ✓ Off-diagonal coherences properly extracted")
print(f"  ✓ Full density matrix reconstruction via MLE")
print(f"  ✓ Physical constraints enforced (positive semi-definite)")
print(f"  ✓ Validation against analytical Bell state")
print(f"\nFinal results in: {summary_file}")
